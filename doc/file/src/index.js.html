<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | Stardux API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-style.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/littlstar/stardux.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~Container.html">Container</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-clearContainers">clearContainers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-composeContainers">composeContainers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createContainer">createContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createContainerUid">createContainerUid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fetchContainer">fetchContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-forEachContainer">forEachContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAllContainers">getAllContainers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getContainerData">getContainerData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeContainer">makeContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-realignContainerTree">realignContainerTree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-removeContainer">removeContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-replaceDOMElement">replaceDOMElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-restoreContainerFromJSON">restoreContainerFromJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-restoreOrphanedTree">restoreOrphanedTree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-saveContainer">saveContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-traverseContainer">traverseContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UPDATE">UPDATE</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

/**
 * Module dependencies.
 *
 * @ignore
 */

import { combineReducers, createStore } from &apos;redux&apos;
import { Parser, Template } from &apos;starplate&apos;
import esprima from &apos;esprima&apos;
import extend from &apos;extend&apos;
import domify from &apos;domify&apos;

/**
 * Container symbols.
 *
 * @private
 */

const $domElement = Symbol(&apos;Element&apos;)
const $middleware = Symbol(&apos;middleware&apos;)
const $children = Symbol(&apos;children&apos;)
const $pipes = Symbol(&apos;pipes&apos;)
const $model = Symbol(&apos;model&apos;)
const $store = Symbol(&apos;store&apos;)
const $uid = Symbol(&apos;uid&apos;)

/**
 * Private stardux data attached to
 * traversed DOM elements.
 *
 * @private
 * @const
 * @type {String}
 */

const STARDUX_PRIVATE_ATTR = &apos;__starduxData&apos;

/**
 * Reducer action type symbols.
 *
 * @private
 * @const
 * @type {Symbol)
 */

const $UPDATE_ACTION = Symbol(&apos;UPDATE&apos;)

/**
 * Known container map by ID
 *
 * @private
 * @type {Map}
 */

const CONTAINERS = new Map()

/**
 * Clones an object.
 *
 * @private
 * @param {Object} object
 * @return {Object}
 */

function clone (object) {
  return extend(true, {}, object)
}

/**
 * Detects if input is &quot;like&quot; an array.
 *
 * @private
 * @param {Mixed} a
 * @return {Boolean}
 */

function isArrayLike (a) {
  if (&apos;object&apos; != typeof a)
    return false
  else if (null == a)
    return false
  else
    return Boolean( Array.isArray(a)
                    || null != a.length
                    || a[0] )
}

/**
 * Make stardux data object on a
 * node if not already there.
 *
 * @private
 * @param {Object} node
 * @param {Object} [data = {}]
 * @return {Object}
 */

function mkdux (node, data = {}) {
  if (node instanceof Container)
    node = node.domElement
  node[STARDUX_PRIVATE_ATTR] = ( node[STARDUX_PRIVATE_ATTR] || data )
  return node[STARDUX_PRIVATE_ATTR]
}

/**
 * Remove stardux data object.
 *
 * @private
 * @param {Object} node
 */

function rmdux (node) {
  if (null == node) return
  if (node instanceof Container)
    node = node.domElement
  delete node[STARDUX_PRIVATE_ATTR]
}

/**
 * Returns an array of known tokens
 * in a javascript string.
 *
 * @private
 * @param {String} string
 * @return {Array}
 */

function getTokens (string) {
  let tokens = null
  try { tokens = esprima.tokenize(&apos;`&apos;+ string +&apos;`&apos;) }
  catch (e) { tokens = [] }
  return tokens
}

/**
 * Returns an object of identifiers with
 * empty string or NO-OP function
 * values.
 *
 * @private
 * @param {Array} tokens
 * @return {Object}
 */

function getIdentifiersFromTokens (tokens) {
  const identifiers = {}

  /**
   * Predicate to determine if token is an identifier.
   *
   * @private
   * @param {Object} token
   * @return {Boolean}
   */

  const isIdentifier = token =&gt; &apos;Identifier&apos; == token.type

  /**
   * Mark token as a function identifier.
   *
   * @private
   * @param {Object} token
   * @param {Number} index
   * @return {Object} token
   */

  const markFunction = (token, index) =&gt; {
    const next = tokens[index + 1] || null
    token.isFunction = ( &apos;Identifier&apos; == token.type
                        &amp;&amp; &apos;object&apos; == typeof next &amp;&amp; next
                        &amp;&amp; &apos;Punctuator&apos; == next.type
                        &amp;&amp; &apos;(&apos; == next.value
                          ? true : false )
    return token
  }

  /**
   * Mark token as a object identifier.
   *
   * @private
   * @param {Object} token
   * @param {Number} index
   * @return {Object} token
   */

  const markObject = (token, index) =&gt; {
    const next = tokens[index + 1] || null
    token.isObject = ( &apos;Identifier&apos; == token.type
                      &amp;&amp; &apos;object&apos; == typeof next &amp;&amp; next
                      &amp;&amp; &apos;Punctuator&apos; == next.type
                      &amp;&amp; &apos;.&apos; == next.value
                        ? true : false )
    return token
  }

  /**
   * Assign token value to identifierss map.
   *
   * @private
   * @param {Object} map
   * @param {Object} token
   * @return {Object} map
   */

  const assign = (map, token) =&gt; {
    const value = token.value
    if (token.isFunction)
      map[value] = _ =&gt; &apos;&apos;
    else if (token.isObject)
      map[value] = {}
    else
      map[value] = &apos;&apos;
    return map
  }

  // resolve identifierss and return map
  return ( tokens
          .map((t, i) =&gt; markFunction(t, i))
          .map((t, i) =&gt; markObject(t, i))
          .filter(t =&gt; isIdentifier(t))
          .reduce((map, t) =&gt; assign(map, t), identifiers) )
}

/**
 * Ensures a DOM string from a given input.
 *
 * @private
 * @param {String} html
 * @return {String}
 */

function ensureDOMString (html = &apos;&apos;) {
  html = &apos;string&apos; == typeof html ? html : String(html || &apos;&apos;)
  return html.trim()
}

/**
 * Ensure DOM element.
 *
 * @private
 * @param {Mixed} input
 * @return {Element}
 */

function ensureDOMElement (input) {
  let domElement = null
  let tmp = null
  if (input instanceof Element) {
    return input
  } else if (&apos;string&apos; == typeof input) {
    tmp = document.createElement(&apos;div&apos;)
    tmp.innerHTML = input
    domElement = tmp.innerHTML.length ? tmp.children[0] : new Template(input)
  } else {
    domElement = document.createElement(&apos;div&apos;)
  }
  return domElement
}

/**
 * Returns a template tring from a given
 * DOM Element. If the DOM Element given is a
 * string then it is simply returned.
 *
 * @public
 * @param {Element|String} domElement
 * @return {String}
 */

function getTemplateFromDomElement (domElement) {
  let data = {}
  let src = null

  if (domElement &amp;&amp; domElement[STARDUX_PRIVATE_ATTR])
    data = mkdux(domElement)

  if (&apos;string&apos; == typeof domElement)
    src = domElement
  else if (data.src)
    src = data.src
  else if (domElement.children &amp;&amp; 0 == domElement.children.length)
    src = ensureDOMString(domElement.textContent)
  else if (domElement.firstChild instanceof Text)
    src = ensureDOMString(domElement.innerHTML)
  else if (domElement instanceof Text)
    src = ensureDOMString(domElement.textContent)
  else if (domElement)
    src = domElement.innerHTML || domElement.textContent

  return src
}

/**
 * Ensures container state identifiers (tokens) derived from
 * the DOM element source are defined on the state if not
 * already. This is useful to prevent reference errors from
 * being thrown when ES6 templates are evaulated in starplate&apos;s
 * VM.
 *
 * @private
 * @param {Container} container
 * @return {Object} identifiers
 */

function ensureContainerStateIdentifiers (container) {
  const domElement = container[$domElement]
  const template = getTemplateFromDomElement(domElement)
  const tokens = getTokens(template)
  const identifiers = getIdentifiersFromTokens(tokens)
  const update = {}
  const state = container.state
  if (identifiers) {
    for (let key in identifiers) {
      if (undefined === state[key])
        update[key] = identifiers[key]
    }

    container.define(update)
  }
  return identifiers || null
}

/**
 * Creates a root reducer for a Container
 * instance.
 *
 * @private
 * @param {Container} container
 * @return {Function}
 */

function createRootReducer (container) {
  return (state = {}, action = {data: {}}) =&gt; {
    const identifiers = ensureContainerStateIdentifiers(container)
    const domElement = container[$domElement]
    const template = getTemplateFromDomElement(domElement)
    const middleware = container[$middleware].entries()
    const isBody = domElement == document.body

    action.data = action.data || {}

    /**
     * Loops over each middleware function
     * providing state and action values
     * given to use from redux.
     *
     * @private
     */

    void function next () {
      const step = middleware.next()
      const done = step.done
      const reducer = step.value ? step.value[0] : null
      if (done) return
      else if (null == reducer) next()
      else if (false === reducer(state, action)) return
      else next()
    }()

    switch (action.type) {
      case $UPDATE_ACTION:
        container.define(action.data)
        if (!isBody &amp;&amp; identifiers) {
          const parser = new Parser()
          const partial = new Template(template)
          const src = partial.render(container.state, container)
          const patch = parser.createPatch(src)
          patch(domElement)
      }
      break
    }

    return extend(true, container.state, state, action.data)
  }
}

/**
 * Creates a pipe reducer for a Container
 * instance.
 *
 * @private
 * @param {Container} container
 * @return {Function}
 */

function createPipeReducer (container) {
  return (_, action = {data: {}}) =&gt; {
    const state = container.state
    const pipes = container[$pipes].entries()
    reduce()
    return container.state

    /**
     * Loops over each pipe function
     * providing state and action values
     * given to use from redux.
     *
     * @private
     */

    function reduce () {
      const step = pipes.next()
      const done = step.done
      const pipe = step.value ? step.value[1] : null
      if (done) return
      else if (false === pipe(state, action)) return
      else return reduce()
    }
  }
}

/**
 * Orphan container.
 *
 * @private
 * @param {Container} container
 * @param {Boolean} [rouge]
 */

function orphanContainerChildren (container, rouge = false) {
  container = fetchContainer(container)

  const children = container.children

  if (null == container)
    throw new TypeError( &quot;orphanContainerChildren() Expecting a container &quot; )

  for (let child of children) {
    container.removeChild(child)
    if (true === rouge) {
      orphanContainerChildren(child, true)
      CONTAINERS.delete(child.id)
    }
  }
}

/**
 * The action type dispatched by the update() method.
 *
 * @example &lt;caption&gt;Handle update actions in middleware and reducers.&lt;/caption&gt;
 *
 *   // Use this value to determine what type of
 *   // action was dispatched in a reducer or
 *   // middleware function
 *   (state, action) =&gt; {
 *     if (UPDATE == action.type) {
 *        // reducer/middleware logic here
 *     }
 *   }
 *
 * @public
 * @const
 * @type {Symbol}
 */

export const UPDATE = $UPDATE_ACTION

/**
 * Create a new Container instance with optional
 * initial state and n reducers.
 *
 * @example &lt;caption&gt;Create an anonymouse container.&lt;/caption&gt;
 *   const container = createContainer()
 *
 * @example &lt;caption&gt;Create a container for a DOM Element.&lt;/caption&gt;
 *   const container = createContainer(domElement)
 *
 * @example &lt;caption&gt;Create a container for a DOM Element with initial state.&lt;/caption&gt;
 *   const container = createContainer(domElement, {value: 0})
 *
 * @example &lt;caption&gt;Create a container for a DOM Element with initial state and reducers.&lt;/caption&gt;
 *   const container = createContainer(domElement, {value: 0}, (state = {}, action) =&gt; {
 *     if (UPATE == action.type) {
 *        return {
 *          value: state.action + action.data.value
 *        }
 *     }
 *   })
 *
 * @public
 * @param {Element} domElement
 * @param {?(Object)} [initialState] - Initial state object
 * @param {...Function} [reducers]
 * @return {Container}
 */

export function createContainer (domElement, initialState = null, ...reducers) {
  const container = ( fetchContainer(domElement)
                   || new Container(domElement, ...reducers) )
  return container.update(initialState)
}

/**
 * Creates a or returns a new Container instance
 * from a given DOM element.
 *
 * If a DOM element is already associated with
 * a container then the container is just
 * returned, otherwise a new one is created.
 *
 * @example &lt;caption&gt;Make a container for a DOM Element.&lt;/caption&gt;
 *   const container = makeContainer(document.body)
 *
 * @public
 * @param {Element} domElement
 * @return {Container}
 */

export function makeContainer (domElement) {
  let container = null
  if (false == (domElement instanceof Element))
    throw new TypeError(&quot;makeContainer() expects a DOM element.&quot;)
  container = fetchContainer(domElement) || new Container(domElement)
  return container
}

/**
 * Create or restore a Container instance
 * from a JSON object with an optional state
 * object a reducers.
 *
 * Containers are created if they do not already
 * exist internally.
 *
 * @example &lt;caption&gt;Restore or create a container from JSON.&lt;/caption&gt;
 *   const container = restoreContainerFromJSON(json)
 *
 * @example &lt;caption&gt;Restore or create a container from JSON with initial state.&lt;/caption&gt;
 *   const container = restoreContainerFromJSON(json, {value: 0})
 *
 * @example &lt;caption&gt;Restore or create a container from JSON with initial state and reducers.&lt;/caption&gt;
 *   const container = restoreContainerFromJSON(json, {value: 0}, ...reducers)
 *
 * @public
 * @param {Object} json
 * @param {?(Object)} [initialState] - Initial state object
 * @param {...Function} [reducers]
 * @return {Container}
 */

export function restoreContainerFromJSON (json, initialState = null, ...reducers) {
  const id = json.id
  const src = json.src
  let data = null
  let children = []
  let container = fetchContainer(id)
  let domElement = null

  if (null == container)
    container = new Container(null, ...reducers)

  container[$uid] = id
  domElement = container.domElement
  data = mkdux(domElement)

  saveContainer(container)

  if (src != data.src)
    data.src = src

  if (initialState)
    container.update(initialState)

  for (let child of json.children)
    children.push(restoreContainerFromJSON(child, initialState))

  realignContainerTree(container, true, true)

  for (let child of children)
    if (false == container.contains(child))
      container.appendChild(child, false)

  return container.update()
}

/**
 * Compose a container from containers or DOM elements.
 * If a Container or Element is given as first argument then
 * it is treated as the root and all subsequent arguments are
 * treated as direct descendants of the root. If the second
 * argument is an array or an &quot;array like&quot; object then it is
 * treated as direct descendants of the root and all subsequent
 * arguments are ignored. If an array or &quot;array like&quot; object is
 * passed as the first argument a new root container is created
 * and the first argument is treated as direct descendants of
 * the newly created root container. The root container, newly
 * created or restored is returned.
 *
 * @example &lt;caption&gt;Compose containers together with new root.&lt;/caption&gt;
 *   const a = createContainer()
 *   const b = createContainer()
 *   const composed = composeContainers([a, b])
 *
 * @example &lt;caption&gt;Compose containers together with given root.&lt;/caption&gt;
 *   const a = createContainer()
 *   const b = createContainer()
 *   const c = createContainer()
 *   const composed = composeContainers(a, [b, c])
 *
 * @public
 * @param {?(Element|Container)} root
 * @param {?(...Element|Container|String)} containers
 * @return {Container}
 */

export function composeContainers (root, ...containers) {
  let composed = null
  let updateChildren = false
  const children = []

  // array of containers
  if (isArrayLike(root)) {
    containers = [ ...root ].map(createContainer)
    root = null
  } else {
    // derive containers from arguments
    if (isArrayLike(containers[0]))
      containers = [ ...containers[0] ]
    containers = [ ...containers ].map(createContainer)
  }

  composed = createContainer(root || undefined)

  // create composite
  let composite = composed
  for (let child of containers) {
    if (false == composite.contains(child))
      composite = composite.pipe(child)
  }

  // realign root tree
  realignContainerTree(composed, true)

  // allow consumer to unwind composition
  composed.decompose = _ =&gt; {
    let composite = composed
    for (let child of containers)
      composite = composite.unpipe(child)
    // remove this function
    delete composed.decompose
    return composed
  }

  return composed
}

/**
 * Returns immutable private stardux data for a given
 * input. Input can be a container, an Element,
 * or a string representing a container ID. If data is
 * not found then null is returned.
 *
 * @example &lt;caption&gt;Get container data for a container.&lt;/caption&gt;
 *   const data = getContainerData(container)
 *
 * @example &lt;caption&gt;Get container data for a container from a given DOM element.&lt;/caption&gt;
 *   const data = getContainerData(container)
 *
 * @example &lt;caption&gt;Get container data for a container from a given id.&lt;/caption&gt;
 *   const data = getContainerData(id)
 *
 * @public
 * @param {Container|Element|String} arg
 * @return {Object}
 */

export function getContainerData (arg) {
  let data = null
  let domElement = null
  const container = fetchContainer(arg)

  if (!(arg instanceof Container
     || arg instanceof Element
     || &apos;string&apos; == typeof arg)) {
    throw new TypeError( &quot;Unexpected input for getContainerData. &quot;
                       + &quot;Expecting an instance of a Container or Element, &quot;
                       + &quot;or a string.&quot; )
  }

  if (container)
    domElement = container.domElement

  if (domElement)
    data = domElement[STARDUX_PRIVATE_ATTR]
  return data ? Object.freeze(data) : null
}

/**
 * Restores orphaned children containers
 * still attached to a container. An orphan
 * container is a container who belongs to
 * a set of containers and it&apos;s DOM element
 * is not attched to a DOM tree (The parent
 * container&apos;s DOM element).
 *
 * @public
 * @param {Container|Element} container
 * @param {Boolean} [recursive]
 */

export function restoreOrphanedTree (container, recursive = false) {
  if (container instanceof Element)
    container = fetchContainer(container)

  if (null == container)
    return

  const domElement = container.domElement
  const children = container[$children]

  for (let child of [ ...children ]) {
    const childDomElement = child.domElement

    if (false == domElement.contains(childDomElement))
      domElement.appendChild(childDomElement)

    if (recursive)
      restoreOrphanedTree(child, true)
  }
}

/**
 * Realign container DOM tree by removing containers
 * not found in container DOM tree. If recursive is set to
 * true then realignment is applied to all subsequent child
 * containers. If forceOrphanRestoration is set to true then
 * orphan containers are restored.
 *
 * @public
 * @param {Container} container
 * @param {Boolean} [recursive]
 * @param {Boolean} [forceOrphanRestoration]
 */

export function realignContainerTree (container,
                                      recursive = false,
                                      forceOrphanRestoration = false) {
  const domElement = container.domElement
  const children = container[$children]

  if (null == domElement.children)
    return

  const delta = [ ...children ].length - domElement.children.length

  if (delta &gt; 0 || true === forceOrphanRestoration)
    restoreOrphanedTree(container, recursive)

  // purge child containers existing in tree where
  // the DOM element is not a child of the container
  // DOM element.
  for (let child of [ ...children ]) {
    const childElement = child.domElement
    if (false == domElement.contains(childElement))
      children.delete(child)
  }

  // traverse children
  for (let childElement of [ ...domElement.children ]) {
    const data = childElement[STARDUX_PRIVATE_ATTR]
    const child = &apos;object&apos; == typeof data ? fetchContainer(data.id) : null

    // skip DOM elements which are not claimed
    // by any existing containers
    if (null == child)
      continue

    children.add(child)

    // recurse child containers
    if (true === recursive)
      realignContainerTree(child, true, forceOrphanRestoration)
  }
}


/**
 * Save a container to the known containers map. A
 * DOM element may be passed if it has been claimed by
 * a Container instance.
 *
 * @example &lt;caption&gt;Save a container&lt;/caption&gt;
 *   saveContainer(container)
 *
 * @example &lt;caption&gt;Save a container by DOM element&lt;/caption&gt;
 *   saveContainer(domElement)
 *
 * @public
 * @param {(Container|Element)} container
 * @return {Boolean}
 */

export function saveContainer (container) {
  container = fetchContainer(container) || container
  if (container &amp;&amp; container.id &amp;&amp; !CONTAINERS.has(container.id)) {
    CONTAINERS.set(container.id, container)
    return true
  }
  return false
}

/**
 * Fetch a saved container by container ID,
 * DOM element, or by a container instance.
 *
 * @example &lt;caption&gt;Fetch container by id.&lt;/caption&gt;
 *   const container = fetchContainer(id)
 *
 * @example &lt;caption&gt;Fetch container by DOM element.&lt;/caption&gt;
 *   const container = fetchContainer(domElement)
 *
 * @example &lt;caption&gt;Fetch container by object with id.&lt;/caption&gt;
 *   const container = fetchContainer({id: id})
 *
 * @public
 * @param {(String|Element|Object)} arg
 * @param {String} [arg.id] - Container ID
 * @return {class Container}
 */

export function fetchContainer (arg) {
  const id = ( arg &amp;&amp; arg.id )
             ? arg.id
             : ( arg &amp;&amp; arg[STARDUX_PRIVATE_ATTR] )
               ? arg[STARDUX_PRIVATE_ATTR].id
               : arg
  return id ? CONTAINERS.get(id) : null
}

/**
 * Generates a unique hex ID for Container instances.
 *
 * @example &lt;caption&gt;Create a unique container ID&lt;/caption&gt;
 *   const id = createContainerUid()
 *
 * @public
 * @return {String}
 */

export function createContainerUid () {
  return ( Math.random() ).toString(&apos;16&apos;).slice(1)
}

/**
 * Returns an interator for all containers.
 *
 * @example &lt;caption&gt;Get an iterator for all containers.&lt;/caption&gt;
 *   const it = getAllContainers()
 *   for (let pair of [ ...it ])
 *     console.log(pair)
 *
 * @public
 * @return {Array&lt;MapIterator&gt;}
 */

export function getAllContainers () {
  return CONTAINERS.entries()
}

/**
 * Execute a function for each container.
 *
 * @example
 *   forEachContainer(container =&gt; {
 *     console.log(container)
 *   })
 *
 * @public
 * @param {Function} fn
 * @param {Object} [scope]
 */

export function forEachContainer (fn, scope = null) {
  const containers = getAllContainers()
  fn = &apos;function&apos; == typeof fn ? fn : _ =&gt; void 0
  for (let kv of containers)
    fn.call(scope || global, kv[1], containers)
}

/**
 * Traverse a container&apos;s tree recursively.
 *
 * @example
 *   traverseContainer(container, child =&gt; {
 *     console.log(child)
 *   })
 *
 * @public
 * @param {Container} container
 * @param {Function} fn
 * @param {Object} [scope]
 */

export function traverseContainer (container, fn, scope) {
  const children = container.children
  for (let child of [ ...children ]) {
    fn.call(scope || global, child, children)
    traverseContainer(child, fn, scope)
  }
}

/**
 * Removes a container from the internal tree.
 * The container is also removed from its parent
 * if it is attched to one. A string ID, DOM element,
 * or Container may be used as an argument.
 *
 * @example &lt;caption&gt;Remove container by id.&lt;/caption&gt;
 *   removeContainer(id)
 *
 * @example &lt;caption&gt;Remove container by DOM element.&lt;/caption&gt;
 *   removeContainer(domElement)
 *
 * @example &lt;caption&gt;Remove container by object with id.&lt;/caption&gt;
 *   removeContainer({id: id})
 *
 * @public
 * @param {(String|Container|Element)} arg
 * @param {Boolean} [recursive]
 * @return {Boolean}
 */

export function removeContainer (arg, recursive = false) {
  const container = fetchContainer(arg)
  const id = container ? container.id : null
  if (id &amp;&amp; CONTAINERS.has(id)) {
    if (recursive) {
      for (let child of container.children)
        removeContainer(child, true)
    }

    // remove from parent
    if (container.parent)
      container.parent.removeChild(container, false, true)

    // remove stardux data
    rmdux(container.domElement)

    // remove from tree
    CONTAINERS.delete(id)
    return true
  }
  return false
}

/**
 * Clears all saved containers. This will call
 * removeContainer for every saved container.
 *
 * @public
 * @return {undefined}
 */

export function clearContainers () {
  // remove stardux data for each container
  forEachContainer(container =&gt; removeContainer(container))

  // sanity clear containers
  CONTAINERS.clear()
}

/**
 * Replace container element with another. This will remove all
 * children containers and realign the container tree.
 *
 * @public
 * @param {Container} container
 * @param {Element} domElement
 * @return {Container}
 */

export function replaceDOMElement (container, domElement) {
  const existingData = mkdux(domElement)
  const data = mkdux(container.domElement)
  if (domElement &amp;&amp; domElement != container.domElement) {
    mkdux(domElement, data)

    const id = container.id
    const sources = []
    const childElements = [ ...domElement.children ]
    const parent = container.parent
    const children  = container.children
    const parentElement = parent ? parent.domElement : null
    const previousDomElement = container.domElement
    const existingContainer = fetchContainer(existingData.id)

    if (existingContainer) {
      throw new TypeError( &quot;replaceDOMElement() expects an unclaimed &quot;
                         + &quot;DOM Element.&quot; )
    }

    orphanContainerChildren(id, 0 == children.length)

    // free DOM element of dux data
    rmdux(previousDomElement)
    container[$domElement] = domElement
    container[$children].clear()

    for (let childElement of childElements)
      storeChildSource(childElement)

    container.update(null, false)

    const stack = sources.slice()
    for (let childElement of [ ...domElement.children ])
      restoreChildElementSource(childElement, stack)

    container[$domElement].innerContents = domElement.innerHTML

    realignContainerTree(container, true, true)

    function storeChildSource (node) {
      const data = mkdux(node)
      sources.push(data.src || node.innerHTML)
      for (let child of [ ...node.children ])
        storeChildSource(child)
    }

    function restoreChildElementSource (node, stack) {
      const parser = new Parser()
      const source = stack.shift()
      const data = extend(mkdux(node), {src: source})
      const patch = source ? parser.createPatch(source) : null
      if (patch) patch(node)
      for (let child of [ ...node.children ])
        restoreChildElementSource(child, stack)
    }
  }
  return container
}


/**
 * Container class.
 *
 * @public
 * @class Container
 */

export class Container {

  /**
   * Container constructor.
   *
   * @public
   * @constructor
   * @param {Element|String} domElement
   * @param {Function} ...reducers
   */

  constructor (domElement = null, ...reducers) {
    // ensure DOM element instance
    domElement = ensureDOMElement(domElement)

    /**
     * Container UID
     *
     * @private
     * @type {String}
     */

    this[$uid] = createContainerUid()

    /**
     * Instance root DOM Element.
     *
     * @private
     * @type {Element}
     */

    this[$domElement] = domElement

    /**
     * Middleware set.
     *
     * @private
     * @type {Set}
     */

    this[$middleware] = new Set()

    /**
     * Known container pipes.
     *
     * @private
     * @type {Set}
     */

    this[$pipes] = new Map()

    /**
     * View model.
     *
     * @private
     * @type {Object}
     */

    this[$model] = {}

    /**
     * Child containers.
     *
     * @private
     * @type {Set}
     */

    this[$children] = new Set()

    /**
     * Redux store.
     *
     * @private
     * @type {Object}
     */

    this[$store] = createStore(combineReducers([
      // The root reducer handles container state updates
      // and propagates them to the internal DOM element
      // via starplate templates. The DOM tree is patched,
      // not redrawn. Middleware consumption is also applied
      // here. The state and action objects provided by redux
      // may be modified.
      createRootReducer(this),

      // User provided reducers from the class constructor. The
      // state and action objects may be modified from their original
      // states when dispatched due to middleware side effects applied
      // in  the root reducer.
      ...reducers,

      // Piped reducers are applied when composition occurs between
      // two containers. They are achievd with the pipe() method. All
      // dispatched actions are propagated to the piped container via
      // this reducer. They actually don&apos;t reduce state, but simply pass
      // it on. When an update action occurs via an update() on a container
      // all containers it has been piped to will effectively have their
      // update() methods called with the provided data arguments. Please
      // note that any middleware applied to parent of a pipe chain will
      // affect the input of the child of a pipe chain.
      createPipeReducer(this),
    ]))

    // Replace DOM element with itself effectively
    // restoring orphaned or lost stardux data.
    replaceDOMElement(this, domElement)

    // ensure container state identifers found in
    // DOM element source is predefined on the internal
    // state object.
    ensureContainerStateIdentifiers(this)

    // Save this container to the internal container map
    saveContainer(this)

    // Realign parent tree recursively if it exists and restore
    // orphaned child containers. This will cause all
    // child containers to realign themselves recursively.
    if (this.parent)
      realignContainerTree(this.parent, true, true)
    // Realign container and all orphaned child containers if
    // found in the tree. This will cause child containers to
    // realign themselves.
    else
      realignContainerTree(this, true, true)
  }

  /**
   * Copy of the internal state object.
   *
   * @public
   * @type {Object}
   */

  get state () {
    return clone(this[$model])
  }

  /**
   * Container id.
   *
   * @public
   * @type {String}
   */

  get id () {
    return this[$uid]
  }

  /**
   * Getter to return parent container if
   * available. Parent is determined with
   * DOM traversal up the tree. A container can
   * be considered orphaned if it doesn&apos;t have a
   * parent DOM element.
   *
   * @public
   * @type {Container|null}
   */

  get parent () {
    const domElement = this.domElement
    let parentElement = domElement &amp;&amp; domElement.parentElement
    let parentContainerData = {}
    let parentElementContainer = null
    do {
      if (null == parentElement) break
      parentContainerData = parentElement[STARDUX_PRIVATE_ATTR] || {}
      parentElement = parentElement.parentElement
    } while (!(parentElementContainer = fetchContainer(parentContainerData.id)))
    return parentElementContainer
  }

  /**
   * Container DOM element.
   *
   * @public
   * @type {Element}
   */

  get domElement () {
    return this[$domElement]
  }

  /**
   * DOM element setter that basically just
   * calls replaceDOMElement(domElement).
   *
   * @ignore
   * @public
   * @type {Element}
   */

  set domElement (domElement) {
    if (domElement instanceof Element)
      replaceDOMElement(this, domElement)
    else throw new TypeError( &quot;Cannot set property .domElement. Value must &quot;
                            + &quot;be an Element.&quot; )
    return this.domElement
  }

  /**
   * Internal contents of the container
   *
   * @public
   * @type {String}
   */

  get innerContents () {
    return this.domElement.innerHTML || &apos;&apos;
  }

  /**
   * Sets inner contents of DOM content.
   * This will set the template source
   * and update the container. If child
   * containers exist in tree they will
   * become orphaned. If value is null
   * then the value becomes an empty
   * string (&apos;&apos;). undefined values result
   * in the string &apos;undefined&apos;.
   *
   * @ignore
   * @public
   * @type {String}
   */

  set innerContents (value) {
    if (null === value)
      value = &apos;&apos;
    const data = mkdux(this)
    data.src = String(value)
    this.update()
  }

  /**
   * Child containers
   *
   * @public
   * @return {Array&lt;Container&gt;}
   */

  get children () {
    return [ ...this[$children].entries() ].map(kv =&gt; kv[0])
  }

  /**
   * Extend view model.
   *
   * @example &lt;caption&gt;Extend current state model.&lt;/caption&gt;
   *   container.define({value: 0})
   *
   * @public
   * @param {Object} model
   * @return {Container}
   */

  define (model) {
    if (&apos;object&apos; == typeof model)
      extend(true, this[$model], model)
    return this
  }

  /**
   * Consume reducer middleware.
   *
   * @example &lt;caption&gt;Install reducer middleware plugin.&lt;/caption&gt;
   *   container.use((state = {}, action) =&gt; { ... })
   *
   * @public
   * @param {...Function} plugins
   * @return {Container}
   */

  use (...plugins) {
    const middleware = this[$middleware]
    for (let plugin of plugins)
      middleware.add(plugin)
    return this
  }

  /**
   * Updates container and all child containers.
   *
   * @example &lt;caption&gt;Update container and its children&lt;/caption&gt;
   *   container.update({value: 0})
   *
   * @example &lt;caption&gt;Update only container and not its children&lt;/caption&gt;
   *   container.update({value: 0}, false)
   *
   * @public
   * @param {Object} [data] - New state data
   * @param {Boolean} [propagate] - Propagate updates to child containers.
   * @return {Container}
   */

  update (data, propagate = true) {
    const domElement = this.domElement
    const template = getTemplateFromDomElement(domElement)

    // init/update DOM data
    extend(mkdux(domElement), { id: this[$uid] })
    if (template) {
      extend(mkdux(domElement), {
        src: getTemplateFromDomElement(domElement)
      })
    }

    // pre alignment
    realignContainerTree(this, true, true)

    // update
    this.dispatch($UPDATE_ACTION, data, { propagate: propagate })

    if (propagate) {
      for (let child of [ ...this.children ]) {
        child.update(data || this.state)
      }
    }

    // post alignment
    realignContainerTree(this)
    return this
  }

  /**
   * Render container to a DOM element.
   *
   * @example &lt;caption&gt;Render container to a given domElement.&lt;/caption&gt;
   *   container.render(document.body)
   *
   * @public
   * @param {Element} domElement
   * @return {Container}
   */

  render (domElement) {
    if (!domElement) return this
    if (false == domElement.contains(this[$domElement])) {
      domElement.appendChild(this[$domElement])
      realignContainerTree(this)
    }
    return this
  }

  /**
   * Dispatch an event with type, optional data
   * and optional arguments to the internal redux store.
   *
   * @example &lt;caption&gt;Dispatch an action with type and optional data and action argument.&lt;/caption&gt;
   *   container.dispatch({
   *     type: &apos;MY_ACTION&apos;,
   *     data: {value: 123},
   *     propagate: false
   *   })
   *
   * @public
   * @param {Mixed} type
   * @param {Object} [data]
   * @param {Object} [args]
   * @return {Container}
   */

  dispatch (type, data = {}, args = {}) {
    if (!type) throw new TypeError(&quot;Failed to dispatch event without type.&quot;)
    const store = this[$store]
    const payload = {type: type, data: data}
    for (let key in args)
      payload[key] = args[key]
    store.dispatch(payload)
    return this
  }

  /**
   * Replace child tree with new children.
   * @public
   *
   * @example
   *  container.replaceChildren([childA, childB, createContainer()])
   *
   * @param {Array&lt;Container|Element&gt;} children
   * @return {Container}
   */

  replaceChildren (children) {
    for (let child of this.children)
      this.removeChild(child, false)

    for (let child of children)
      this.appendChild(child, false)
    return this.update()
  }

  /**
   * Returns the associated value of the
   * container.
   *
   * @public
   * @return {Element}
   */

  valueOf () {
    return this.domElement
  }

  /**
   * Returns the string reprenstation of
   * this container.
   *
   * @public
   * @return {String}
   */

  toString () {
    return this.domElement.textContent
  }

  /**
   * Converts container to a JSON
   * serializable object.
   *
   * @public
   * @return {Object}
   */

  toJSON () {
    const root = {}
    void function traverse (container, node) {
      node.id = container.id
      node.src = getTemplateFromDomElement(container.domElement)
      node.state = container.state || {}
      node.children = []
      for (let child of container.children) {
        const next = {}
        node.children.push(next)
        traverse(child, next)
      }
    }(this, root)
    return root
  }

  /**
   * Pipe container updates to a given container.
   *
   * @example
   *  containerA.pipe(containerB)
   *
   * @public
   * @param {Container} container
   * @return {Container} container
   */

  pipe (container) {
    const pipes = this[$pipes]
    const middleware = (state, action) =&gt; {
      switch (action.type) {
        case $UPDATE_ACTION:
          if (action.data) container.update(clone(action.data))
          break
        default:
          container.dispatch(action.type, action.data, action)
      }
    }

    if (false == pipes.has(container))
      pipes.set(container, middleware)

    return container
  }

  /**
   * Unpipe container updates for a given container.
   *
   * @example
   *  containerA.unpipe(containerB)
   *
   * @public
   * @param {Container} container
   * @return {Container} container
   */

  unpipe (container) {
    const pipes = this[$pipes]
    const reducers = this[$middleware]
    const middleware = pipes.get(container)
    if (middleware) {
      pipes.delete(container)
    }
    return container
  }

  /**
   * Append a child container. A child may be an
   * instance of a Container, Element, Text, or
   * a string. Containers are derived from their input
   * and will cause a DOM tree to be restructured.
   *
   * @example
   *   container.appendChild(child)
   *
   * @public
   * @param {Container|Element|Text|String} child
   * @param {Boolean} [update]
   * @param {Boolean} [realign]
   * @return {Container}
   */

  appendChild (child, update = true, realign = true) {
    const domElement = this.domElement
    let childDomElement = null
    let container = null

    if (child instanceof Container) {
      container = child
    } else if (child instanceof Element) {
      container = createContainer(child)
    } else if (&apos;string&apos; == typeof child || child instanceof Text) {
      container = createContainer(child)
    } else {
      throw new TypeError( &quot;Unexpected input for appendChild. &quot;
                         + &quot;Expecting an instance of a Container, Element, Text &quot;
                         + &quot;or a string.&quot; )
    }

    childDomElement = container.domElement

    if (update) this.update()

    try {
      if (container.parent &amp;&amp; container.parent != this) {
        container.parent.removeChild(container)
      }
      domElement.appendChild(childDomElement)
      this[$children].add(container)
    } catch (e) { console.warn(e) }

    if (realign) realignContainerTree(this)

    return container
  }

  /**
   * Remove a child container. A child may be an
   * instance of a Container or Element. Containers
   * are derived from their input and will cause a
   * DOM tree to be restructured.
   *
   * @example
   *   container.removeChild(child)
   *
   * @public
   * @param {Container|Element} child
   * @param {Boolean} [update]
   * @param {Boolean} [realign]
   * @return {Container}
   */

  removeChild (child, update = true, realign = true) {
    const domElement = this.domElement
    let childDomElement = null
    let container = fetchContainer(child)

    // bail if there is nothing to do
    if (null == container) return this

    childDomElement = container.domElement

    // remove child if it is in tree
    if (domElement.contains(childDomElement))
      domElement.removeChild(childDomElement)

    // remove from container children tree
    this[$children].delete(container)

    // realign tree
    if (realign) realignContainerTree(this)

    return this
  }

  /**
   * Predicate to determine if a container or its
   * DOM element is a child of the container.
   *
   * @example
   *   if (container.contains(child)) {
   *     ...
   *   }
   *
   * @public
   * @param {Container|Element} container
   * @param {Boolean} [recursive]
   * @return {Boolean}
   */

  contains (container, recursive = true) {
    container = fetchContainer(container)
    if (this[$children].has(container)) {
      return true
    } else if (recursive) {
      for (let child of this.children) {
        if (child.contains(container)) {
          return true
        }
      }
    }
    return false
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
